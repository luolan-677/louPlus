linux操作命令
(1)ls命令
ls命令是linux下最常用的命令，ls命令是list的缩写。
ls用来打印出当前目录的清单，通过ls命令不仅可以查看linux文件夹包含的文件，而且可以查看目录和文件权限等信息。
命令格式：
ls [选项][目录名]
常用参数：
-a：-all列出目录下的所有文件，包括以.开头的隐含文件
-l：除了文件名之外，还将文件的权限，所有者，文件大小等信息详细列出来
-h：-human-readable 以容易理解的格式列出文件大小(例如1K 234M 2G)
-t：以文件修改时间排序
常用范例：
例一：列出/home文件夹下的所有文件和目录的详细资料，可以使用如下命令：
ls -a -l /home
ls -al /home
注：d表示目录，-表示文件，文件和目录显示的颜色也不同。
例二：列出当前目录中所有以"d"开头的文件目录的详细内容，可以使用如下命令：
ls -l d*
例三：以容易理解的格式列出/home目录中所有的文件目录的大小，可以使用如下命令：
ls -alh /home
思考题：
1.以容易理解的格式列出/home目录中所有以"d"开头的文件目录的大小。
ls -lh d*
2.列出/home目录中所有以"s"开头的目录。
ls -d /home/s*

(2)cd命令
cd命令是change directory的缩写，切换当前目录至制定的目录。
命令格式：
cd [目录名]
常用范例：
例一：从当前目录进入系统根目录，可以使用如下命令：
cd /
例二：从当前目录进入父目录，可以使用如下命令：
cd .. # ..表示父目录
例三：从当前目录进入当前用户主目录，可以使用如下命令：
cd ~ # ～表示当前用户目录，注意它与系统根目录不是同一个概念
例四：从当前目录进入上次所在的目录，可以使用如下命令：
cd - # -表示上次进入的目录

(3)pwd命令
pwd命令来查看"当前工作目录"的完整路径，是Print Working Directory的缩写。
命令格式：
pwd [选项]
常用参数：
-P：显示实际物理路径，而非使用链接(link)路径
-L：当目录为连接路径时，显示连接路径
常用范例：
例一：显示当前目录所在路径，可以使用如下命令：
pwd
例二：显示当前目录的物理路径，可以使用如下命令：
pwd -P
例三：显示当前目录的连接路径，可以使用如下命令：
pwd -L

(4)mkdir命令
mkdir命令用来创建制定名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。
mkdir命令是make directory的缩写。
命令格式：
mkdir [选项] 目录
常用参数：
-m --mode=模式：设定权限<模式>
-p --parents：可以是一个路径名称，若路径中的某些目录尚不存在，加上此选项后，系统将自动建立好那些尚不存在的目录。
-v --verbose：每次创建新目录都显示信息
常用范例：
例一：递归创建多个目录，可以使用如下命令：
mkdir -p zhou/test
例二：创建权限为777的目录，可以使用如下命令：
mkdir -m 777 zhou
例三：创建目录显示信息，可以使用如下命令：
mkdir -vp zhou/test

(5)rm命令
rm的功能为删除一个目录中的一个或者多个文件或目录，也可以将某个目录下的所有文件及子文件夹目录均删除。
对于链接文件，只会删除链接，原文件均保持不变。
rm命令是remove的缩写。
命令格式：
rm [选项] 文件或目录
常用参数：
-f --force：忽略不存在的文件，从不给提示
-i --interactive：进行交互式删除
-r --recursive：指示rm将参数中列出的全部目录和子目录均递归地删除
-v --verbose：详细显示进行的步骤
常用范例：
例一：删除文件，系统会先询问是否删除，可以使用如下命令：
rm shiyanlou.log
例二：强行删除文件，系统不再提示，可以使用如下命令：
rm -f shiyanlou.log
例三：删除后缀名为.log的所有，删除前逐一询问，可以使用如下命令：
rm *.log / rm -i *.log

(6)mv命令
mv命令功能是用来移动文件或更改文件名，经常用来备份文件或者目录。
mv命令根据第二个参数类型(目录是一个文件还是目录)，决定执行将文件重命名或将其移至一个新的目录中。
当第二个参数类型是文件时，mv命令完成文件重命名。
此时，源文件只能有一个(也可以是源目录名)，它将所给的源文件或目录重命名为给定的目标文件名。
当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。
命令格式：
mv [选项] 源文件或目录 目录文件或目录
常用参数：
-b --back：若需覆盖文件，则覆盖前先行备份。
-f --force：如果目标文件已经存在，不会询问而直接覆盖。
-i --interactive：若目标文件已经存在时，就会询问是否覆盖。
-u --update：若目标文件已经存在，且源文件比较新，才会更新。
-t --target：该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。
常用范例：
例一：将文件shiyanlou.log重命名为zhou.log，可以使用如下命令：
mv shiyanlou.log zhou.log
例二：将文件zhou.log移动到test目录下(test目录必须已经存在，否则执行重命名)，可以使用如下命令：
mv zhou.log test
例三：将文件a.txt移动到test1目录下。如果文件存在，覆盖前会询问是否覆盖，可以使用如下命令：
mv -i a.txt test1

(7)cp命令
cp命令用来复制文件或者目录。
一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已存在，则会询问是否覆盖，不管是否使用了-i参数。
如果在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖，所以命令行和脚本的实行方式有些不同。
命令格式：
cp [选项] 源文件 目录 cp [选项] -t 目录 源文件
常用参数：
-t --target-directory：指定目标目录。
-i --interactive：覆盖前询问(使前面的-n选项失效)。
-n --no-clobber：不覆盖已存在的文件(使前面的-i选项失效)。
-s --symbolic-link：对源文件建立符号链接，而非复制文件。
-f --force：强行复制文件或目录，不论目的文件或目录是否已经存在。
-u --update：使用这项参数后，只会在源文件的修改时间较目的文件更新时，或是对应的目的文件并不存在时，才复制文件。
常用范例：
例一：对文件shiyanlou.log建立一个符号链接syl.log，可以使用如下命令：
cp -s shiyanlou.log syl.log
例二：将test1目录下的所有文件复制到test2目录下，覆盖前询问，可以使用如下命令：
cp -i test1/* test2
例三：将test1目录下的最近最新的文件复制到test2目录下，覆盖前询问：
将test1目录下的最近更新的文件复制到test2目录下，覆盖前询问，可以使用如下命令：
cp -iu test1/* test2

(8)cat命令
cat命令的功能是将文件或者标准输入组合输出到标准输出。
这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，常与重定向符号配合使用。
命令格式：
cat [选项] [文件]
常用参数：
-A --show-all：等价于 -vET。
-b --number-nonblank：对非空输出行编号。
-e：等价于-vE。
-E --show-ends：在每行结束处显示$。
-n --number：对输出的所有行编号，由1开始对所有输出的行数编号。
-s --squeeze-blank：有连续两行以上的空白行，就代换为一行的空白行。
-t：与-vT等价。
-T --show-tabs：将跳格字符显示为^I。
-u：(被忽略)。
-v --show-nonprinting：使用^和M-引用，除了LFD和TAB之外。
常用范例：
例一：把shiyanlou.log的文件内容加上行号后输入zhou.log这个文件里，可以使用如下命令：
cat -n shiyanlou.log > zhou.log
例二：把shiyanlou.log的文件内容加上行号后输入zhou.log这个文件里，多行空格换成一行输出，可以使用如下命令：
cat -ns shiyanlou.log > zhou.log
例三：将zhou.log的文件内容反向显示，可以使用如下命令：
tac zhou.log
注：tac是将cat反过来写，所以它的功能就跟cat相反，cat是由第一行开始到最后一行连续显示在屏幕上，而tac则是最后一行开始到第一行反向显示。

(9)nl命令
nl命令在linux系统中用来计算文件中行号。
nl可以将输出的文件内容自动加上行号，其默认的结果与cat -n有点不太一样。
nl可以将行号做较多的显示设计，包括位数与是否自动补齐0等等的功能。
命令格式：
nl [选项] [文件]
常用参数：
-b：指定行号指定的方式，主要有两种：
-b a：表示不论是否为空行，也同样列出行号(类似cat -n)
-b t：如果有空行，空的那一行不要列出行号(默认值)
-n：列出行号表示的方法，主要有三种：
-n ln：行号在屏幕的最左方显示
-n rn：行号在自己栏位的最右方显示，且不加0
-n rz：行号在自己栏位的最右方显示，且加0
-w：行号栏位的占用的位数
常用范例：
例一：把shiyanlou.log的文件内容加上行号后显示，空行不加行号，可以使用如下命令：
nl -b t shiyanlou.log
例二：把shiyanlou.log的文件内容加上行号后显示，行号分别在屏幕左上方，最右方不加0和最右方加0显示，如下：
nl -n ln shiyanlou.log
nl -n rn shiyanlou.log
nl -n rz shiyanlou.log
例三：把shiyanlou.log的文件内容加上行号后显示，行号在屏幕最右方加0显示，行号栏目占位数为3，可以使用如下命令：
nl -n rz -w 3 shiyanlou.log

(10)more命令
功能类似于cat，cat会将整个文件的内容从上到下显示在屏幕上，more命令会一页一页的显示，方便使用者逐页阅读。
最基本的指令就是按住空格往下翻一页，按住B就会往回翻一页，并且带有字符查找功能。
命令格式：
more [选项] 文件
常用参数：
+n：从第n行开始显示
-n：定义屏幕大小为n行
+/pattern：在每个档案显示前搜寻该字串(pattern)，然后从该字串前两行之后开始显示
-c：从顶部清屏，然后显示
-d：提示"Press space to continue, 'q' to quiet"，禁用响铃功能
-p：通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似
-s：把连续多个空行显示为一行
-u：把文件内容中的下划线去掉
常用操作：
=：输出当前行的行号
q：退出more
空格键：向下滚动一屏
b：返回上一屏
常用范例：
请创建文件shiyanlou，文件内容如下：
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
2014-11-5 a
例一：从第五行开始显示shiyanlou.log文件中的内容，如下：
more +5 shiyanlou.log
例二：从shiyanlou.log文件中查找第一个出现"g"字符串的地方，并从该处前两行开始显示输出，如下：
more +/g shiyanlou.log
例三：设定每屏行数为5，如下：
more -5 shiyanlou.log
例四：使用ll和more命令显示/etc目录信息，如下：
ll /etc | more -10

(11)less命令
less命令也是对文件或者其他输出进行分页显示的工具。
命令格式：
less [选项] 文件
常用参数：
-e：当文件显示结束后，自动离开
-f：强迫打开特殊文件，例如外围设备代号，目录和位二进制文件
-i：忽略搜索时的大小写
-m：显示类似more命令的百分比
-N：显示每行的行号
-s：显示连续空行为一行
常用操作：
/字符串：向下搜索"字符串"的功能
?字符串：向上搜索"字符串"的功能
n：重复前一个搜索(与/或?有关)
N：反向重复前一个搜索(与/或?有关)
b：向前翻一页
d：向后翻半页
q：退出less命令
空格键：向后翻一页
向上键：向上翻一行
向下键：向下翻一行
常用范例：
例一：显示shiyanlou.log文件中的内容，并显示行号，如下：
less -N shiyanlou.log
例二：显示siyanlou.log文件中的内容，搜索字符串"shiyanlou"，如下：
less siyanlou.log
/shiyanlou
例三：ps查看进程信息并通过less分页显示，如下：
ps -f | less
*****less与cat和more的区别*****：
cat命令功能：用于显示整个文件的内容，因为单独使用没有翻页功能，所以经常和more命令搭配使用。
             cat命令还有一个可以将数个文件合并成一个文件的功能。
more命令功能：让画面在显示满一页时暂停，此时可按空格键继续显示下一个画面，或按q键停止显示。
less命令功能：less命令的用法与more命令相似，也可以用来浏览超过一页的文件。
              所不同的是less命令除了可以按空格键向下显示文件外，还可以利用上下键来滚动文件。
              当要结束浏览时，只要在less命令的提示符":"下按q即可。
这三个命令除了cat能合并文件外，功能都很相近，使用习惯不同。

(12)head命令：
head命令就像它的名字一样，主要是用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。
命令格式：
head [选项] [文件]
常用参数：
-q：隐藏文件名
-v：显示文件名
-c<字节>：显示字节数
-n<行数>：显示的行数
常用范例：
例一：显示shiyanlou.log文件中前5行的内容，如下：
head -n 5 shiyanlou.log
例二：显示shiyanlou.log和zhou.log文件中的前5行内容，如下：
head -n 5 shiyanlou.log zhou.log

(13)tail命令
tail命令主要用于显示指定文件末尾内容，常用于查看日志。
命令格式：
tail [选项] [文件]
常用参数：
-f：循环读取
-q：不显示处理信息
-v：显示详细的处理信息
-c<字节>：显示的字节数
-n<行数>：显示行数
常用范例：
例一：显示shiyanlou.log文件中的最后5行内容，如下：
tail -n 5 shiyanlou.log
例二：显示shiyanlou.log文件中的最后5行内容，当shiyanlou.log文件有新内容增加时自动更新显示，如下：
tail -n 5 -f shiyanlou.log
注：tail命令的-f选项可以即时输出文件变化后追加的内容，所以可以看到最新的文件内容。

(14)which命令
which命令的作用是，在PATH变量指定的路径中搜索可执行文件的所在位置，一般用来确认系统中是否安装了指定的软件。
命令格式：
which可执行文件名称
常用范例：
例一：确认是否安装了gcc，如下：
which gcc
例二：查看cd命令的位置路径，如下：
which cd
注：从上面的显示信息可以看到在当前实验楼使用的系统中cd是一个shell內建命令。
    但是在某些环境中，我们可以看到cd并不是一个內建函数而是一个shell函数。
    echo $SHELL可以查看当前环境所使用的shell类型。

(15)什么是命令
命令可以是下面的四种形式之一：
1.是一个可执行程序，就像我们所看到的位于目录/usr/bin中的文件一样，属于这一类的程序，可以编译成二进制文件。
  诸如用C和C++语言写成的程序，也可以是由脚本语言写成的程序，比如：shell，python，ruby等等。
2.是一个內建于shell自身的命令。bash支持若干命令，内部叫做shell内部命令(builtins)。
  例如上面本地环境中的cd命令，就是一个shell内部命令。
3.是一个shell函数，这些是小规模的shell脚本，它们混合到环境变量中，比如上面的cd命令，在某些环境中就是一个shell函数。
4.是一个命令别名，我们可以定义自己的命令，建立在其他命令之上。

(16)whereis命令
whereis命令主要用于定位可执行文件，源代码文件和帮助文件在文件系统中的位置。
whereis命令还具有搜索源代码，指定备用搜索路径和搜索不寻常项的功能。
whereis命令查找速度非常快，这是因为它根本不是在磁盘中漫无目的的寻找，而是在一个数据库中(/var/lib/mlocate/mlocate.db)查询。
这个数据库是linux系统自动创建的，包含有本地所有文件的信息。并且每天通过自动执行updatedb命令更新一次。
也正是因为这个数据库要每天才更新一次，所以导致命令搜索的结果有时候会不准确，比如刚添加的文件可能搜索不到。
命令格式：
whereis [选项] 文件
常用参数：
-b：定位可执行文件
-m：定位帮助文件
-s：定位源代码文件
-u：搜索默认路径下除可执行文件，源代码文件和帮助文件以外的其他文件
-B：指定搜索可执行文件的路径
-M：指定搜索帮助文件的路径
-S：指定搜索源代码文件的路径
常用范例：
例一：搜索gcc可执行文件的路径，如下：
whereis -b gcc
例二：搜索gcc帮助文件的路径，如下：
whereis -m gcc
例三：搜索gcc源代码的路径，如下：
whereis -s gcc

(17)locate命令
locate命令跟whereis命令相似，且他们使用的是相同的数据库，但whereis命令只能搜索可执行，联机帮助和源代码文件。
如果要获得全面的搜索结果，可以使用locate命令。
locate命令使用了十分复杂的匹配语法，可以使用特殊字元(如'*'和'?'')来指定需要查找的样本。
命令格式：
locate [选项] [搜索字符串]
常用参数：
-q：安静模式，不会显示任何错误信息
-n：至多显示n个输出
-r：使用正则表达式做寻找的条件
-V：显示版本信息
常用范例：
首先需要安装并更新数据库：
sudo apt-get install locate
sudo updatedb
例一：搜索etc目录下所有以sh开头的文件，可以使用如下命令：
locate /etc/sh
例二：搜索etc目录下文件名包含lou的文件，如下：
locate /etc/*lou*

(18)find命令[一]
find命令主要作用是沿着文件层次结构向下遍历，匹配符号条件的文件，并执行相应的操作。
命令格式：
find [选项] [搜索路径] [表达式]
默认路径是当前路径，默认表达式为-print
表达式可能组成：操作符，选项，测试表达式及动作
常用参数：
-print：find命令将匹配的文件输出到标准输出
-exec：find命令对匹配的文件执行该参数所给出的shell命令
-name：按照文件名查找文件
-type：查找某一类型的文件
-prune：使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find忽略
-user：按照文件属主来查找文件
-group：按照文件所属组来查找文件
-mtime -n +n：按照文件的更改时间来查找文件，-n表示文件更改时间距现在小于n天，+n表示文件更改时间距现在大于n天。
              find命令还有-atime和-ctime选项。
常用范例：
例一：打印当前目录下的文件目录列表，如下：
find . -print
例二：打印当前目录下所有以.txt结尾的文件名，如下：
find . -name "*.txt" -print
-iname选项跟-name选项作用一样，不同的地方在于-iname会忽略字母大小写。
例三：打印当前目录下所有以.txt或.pdf结尾的文件名，可以使用如下：
find . \(-name "*.pdf" -or -name "*.txt"\)
例四：打印当前目录下所有不以.txt结尾的文件名，如下：
find . ! -name "*.txt"
(18)find命令[二]
下面将介绍如何根据文件类型，权限，所有者及操作符来查找匹配文件。
根据文件类型来查找文件，使用-type选项，常见find文件类型见下表：
b：块设备文件
c：字符设备文件
d：目录
f：普通文件
l：符号链接
根据文件权限查找文件，使用-perm选项，所有者使用-user选项。
find命令可以通过逻辑操作符来创建更复杂的逻辑关系，例如find命令[一]中的例三就使用了操作符-or。
find命令的逻辑操作符见下表：
-and：匹配如果操作符两边的测试条件都是真，可以写为-a，注意若没有使用操作符，则默认使用-and
-or：匹配若操作符两边的任一个测试条件为真，可以简写为-o
-not：匹配若操作符后面的测试条件是假，可以简写为一个感叹号！
()：把测试条件和操作符组合起来形成更大的表达式，这用来控制逻辑计算的优先级，默认情况下，find命令按照从左到右的顺序计算。
    经常有必要重写默认的求职顺序，以得到期望的结果，圆括号字符对于shell来说有特殊含义，所以在命令行中使用他们的时候，必须用括号引起来，
    括号引起来才能作为实参传递给find命令，通常反斜杠字符被用来转义圆括号字符。
常用范例：
例一：打印当前目录下所有以.txt结尾的符号链接，可以使用如下命令：
find . -type l -name "*.txt" -print
例二：打印当前目录下所有权限为777的php文件(web服务器上的php文件一般需要执行权限)，如下：
find . -type f -name "*.php" -perm 777
例三：打印当前目录下root用户所拥有的所有文件，如下：
find . -type f -user root
例四：打印当前目录下权限不是777和664的所有文件，如下：
find . -type f \(! -perm 777 -and ! -perm 644 \)
(18)find命令[三]
下面将介绍如何使用find命令的-exec选项来实现对查找到的文件执行指定的动作命令。
常用范例：
例一：找到当前目录下所有php文件，并显示其详细信息，如下：
find . -name "*.php" -exec ls -l {} \;
-exec是find命令对找到的文件执行的动作，这个动作就是对找到的文件执行命令，上面的命令就是ls -l {}。
说明一下{}和\;：{}其实它就是一个占位符，在find命令的执行过程中会不断地替换成当前找到的文件，相当于"ls -l"找到的文件。
\;是-exec命令结束的标记，因为规定-exec后面的命令必须以;结束，但是;在shell中有特殊含义，所以必须要转义。
例二：在实验楼环境中有很多自己在编写的c语言代码文件，现在想要把所有C语言代码文件下载下来，一个下载很麻烦，我们可以先查找到所有C语言代码文件，然后把这些文件内容写入到一个文件中，下载一个文件即可，如下：
find . -name "*.c" -exec cat {} \; > all.c
例三：默认下，-exec后面只能使用单个命令，如果想到多个命令，可以将多个命令写入脚本文件中，然后在-exec中使用这个脚本，如下：
find . -name "*.c" -exec ./command.sh {} \;
脚本内容：
#! /bin/bash
ls -l $1     # $1表示第一个参数
cat $1
注意，直接运行上面的代码可能会提示find './command.sh'：权限不够，这是因为command.sh没有执行权限，赋权即可。

(19)xargs命令
可以用管道将一个命令的stdout(标准输出)重定向到另一个命令的stdin(标准输入)。
但有些命令只能以命令行参数的形式接受数据，无法通过stdin接受数据流，这种情况下就无法通过管道将数据重定向给这些命令。
这时候xargs就可以发挥它的作用了，xargs命令可以从标准输入接受输入，并把输出转换为一个特定的参数列表。
命令格式：
command | xargs [选项] [command]
xargs命令应该紧跟在管道操作符之后，因为它以标准输入作为主要的源数据流。
常用参数：
-n：指定每行最大的参数数量
-d：指定分隔符
常用范例：
例一：将多行输入转换为单行输出，如下：
cat a.txt | xargs
例二：将单行输入转换为多行输出，如下：
echo "1 2 3 4 5 6 7" | xargs -n 3
-n用于指定每行最大的参数数量值。
例三：将单行输入转换为多行输出，指定分隔符为i，如下：
cat b.txt | xargs -d i -n 3
例四：查找当前目录下所有c代码文件，统计总行数，如下：
find . -type f -name "*.c" | xargs wc -l

(20)wc命令
wc命令是一个统计的工具，主要用来显示文件所包含的行，字和字节数。
wc命令是word count的缩写。
命令格式：
wc [选项] [文件]
常用参数：
-c：统计字节数
-l：统计行数
-m：统计字符数，这个标志不能与-c标志一起使用
-w：统计字数，一个字被定义为由空白，跳格或换行字符分隔的字符串
-L：打印最长行的长度
常用范例：
例一：统计文件的字节数，行数和字符数，如下：
wc -c c.txt
wc -l c.txt
wc -m c.txt
注：每行结尾的换行符也算一个字符，空格也算一个字符，另外，由于系统采用UTF-8编码，所以一个汉子算3字节。
例二：统计文件的字节数，行数和字符数，只打印数字，不打印文件名，如下：
cat c.txt | wc -c
cat c.txt | wc -l
cat c.txt | wc -m
例二：统计/bin目录下的命令个数，如下：
ls /bin | wc -l

(21)grep命令
grep用来找文件中的匹配文本，并且能接受正则表达式和通配符，同时可以用多个grep命令选项来生成各种格式的输出。
grep工作方式为：在一个或多个文件中搜索字符串模板，如果模板包括空格，则必须被引用，模板后的所有字符串被看做作文件名。
                搜索的结果被送到标准输出，不影响原文件内容。
grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，不成功则1，文件不存在则2。
命令格式：
grep [选项] pttren [file]
常用参数：
-c：计算找到'搜寻字符串'(即pattern)的次数
-i：忽略大小写的不同，所以大小写视为相同
-n：输出行号
-v：反向选择，打印不匹配的行
-r：递归搜索
--color=auto：将找到的关键词部分加上颜色显示
常用范例：
例一：将etc/passwd文件中出现root的行取出来，关键词部分加上颜色显示，如下：
grep "root" /etc/passwd --color=auto
cat /etc/passwd | grep "root" --color=auto
例二：将/etc/passwd文件中没有出现root和nologin的行取出来，如下：
grep -v "root" /etc/passwd | grep -v "nologin"
例三：在当前目录下递归搜索文件中包含main()的文件，经常用于查找某些函数位于哪些源代码文件中，如下：
grep -r "main()"

(22)正则表达式与grep命令
正则表达式是一种符号表示法，被用来识别文本模式，在某种程度上，他们与匹配文件和路径名的shell通配符比较详细，但规模更大。
正则表达式元字符由以下字符组成：
^ $ . [] {} - ? * + () | \
^：行起始标记：^shiyan匹配以shiyan起始的行
$：行尾标记：$shiyan匹配以shiyan结尾的行
.：匹配任意一个字符：a.c匹配abc，aac，但不匹配abbc
[]：匹配包含在[字符]之中的任意一个字符：ab[cd]匹配abc或abd
[^]：匹配除[^字符]之外的任意一个字符：1[^01]匹配12,13，但不匹配10,11
[-]：匹配[]指定范围内的任意一个字符：[1-5]匹配的任意一个数字
{n}：匹配之前项的n次：[0-9]{2}匹配任意一个两位数，相当于[0-9][0-9]
{n,}：之前的项至少需要匹配n次：[0-9]{2,}匹配任意一个两位或更多位的数字
{n,m}：指定之前的项需要匹配的最小和最大次数：[0-9]{2,5}匹配从两位数到五位数之间的任意一个数字
?：匹配之前的项1次或者0次：shiy?an匹配shiyan或shian
*：匹配之前的项0次或者多次：shiy*an匹配shian，shiyan，shiyyan
+：匹配之前的项1次或者多次：shiy+an匹配shiyan，shiyyan
()：创建一个用于匹配的字串：ma(in)?匹配ma或main
|：匹配 | 两边的任意一项：Dec(1st | 2nd)匹配Dec 1st或者Dec 2nd
\：将上面的特殊字符进行转义：a\+b匹配a+b
常用范例：
例一：利用linux系统自带的字典查找一个五个字母的单词，第三个字母为j，最后一个字母为r，/usr/share/dict目录下存放字典文件，如下：
grep '^..j.r$' words
例二：验证固定电话，打印符合条件的电话，固定电话格式基本都是带有0的区号+连接符"-"+电话号码，另外还有可能有分机号，区号有3，4位，电话有7,8位，如下：
grep -E "^0[0-9]{2,3}-[0-9]{7,8}(-[0-9]{2,3})?$"
如果楼上的命令没有加-E，则没有任何输出，例一没加能输出是因为grep把.当成shell通配符，不是正则表达式的元字符。

(23)cut命令
cut命令是一个将文本按列进行切分的小工具，可以指定分隔每列的定界符。
如果一行数据包含多个字段(多列)，现在想要提取其中的一列或者多列，这时cut命令就可以大显身手了。
命令格式：
cut [选项] [文件名]
常用参数：
-b：以字节为单位进行分割
-c：以字符为单位进行分割
-d：自定义分隔符，默认为制表符
-f：自定义字段
--complement：抽取整个文本行，除了那些由-c或-f选项指定的文本
常用范例：
例一：取出student.txt文件中的第一列和第三列，如下：
cut -f 1,3 -d ' ' student.txt
注：cat默认的分隔符是tab
例二：取出student.txt文件中的第一列，如下：
cut -f 1 -d ' ' student.txt
例三：取出student.txt文件中的前三列，如下：
cut -f 1-3 -d ' ' student.txt
例四：取出student.txt文件中除第一列的其他列，如下：
cut -f 1 -d ' ' student.txt --complement
例五：给任意一字符串str，取出其最后一个字符，如下：
str='shiyanlou'
echo -n $str | cut -b $num
echo -n $str | cut -b `echo -n $str | wc -c`

(24)paste命令
paste命令的功能正好与cut相反，它会添加一个或多个文本列到文件中，而不是从文件中抽取文本列。
它通过读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准输出。
命令格式：
paste [选项] [文件名]
常用参数：
-s：将每个文件合并成行而不是按行粘贴
-d：自定义分隔符，默认为制表符
常用范例：
例一：将student.txt和telphone.txt文件中的内容按列拼接，如下：
paste student.txt telphone.txt
例二：将student.txt和telphone.txt文件中的内容按列拼接，指定分隔符为：，如下：
paste student.txt telphone.txt -d ':'
例三：将student.txt和telphone.txt文件中的内容各自拼接成一行，如下：
paste -s student.txt telphone.txt

(25)tr命令
tr命令常被用来更改字符，我们可以把它看作是一种基于字符的查找和替换操作。
换字是一种把字符从一个字母转换成另一个字母的过程。
tr可以从标准输入中替换，缩减和删除字符，并将结果写到标准输出。
tr只能通过stdin(标准输入)，而无法通过命令行参数来接受输入。
tr是translate的缩写。
命令格式：
tr [选项] SET1 SET2
将来自stdin的输入字符从SET映射到SET2，并将其输出写入stdout(标准输出)。
SET1和SET2是字符类或字符集，如果两个字符集的长度不相等，那么SET2会不断重复其最后一个字符，直到长度与SET1相同。
如果SET2的长度大于SET1，那么SET2中超出SET1的那部分字符则全部被忽略。
常用参数：
-d：删除匹配SET1的内容，并不做替换
常用范例：
例一：将输入的自费大写转换为小写，如下：
echo 'THIS IS SHIYANLOU!' | tr 'A-Z' 'a-z'
例二：将输入的字符中的数字删除，如下：
echo 'THIS 123 IS S1HIY5ANLOU!' | tr -d '0-9'
例三：tr命令的一个有趣的用法是执行ROT13文本编码，ROT13是一款微不足道的基于一种简易的替换暗码的加密类型，把ROT13称为"加密"是不合格的，
      "文本模糊处理"更加准确些，有时候他被用来隐藏文本中潜在的攻击内容，这个方法就是简单地把每个字符在字母表中向前移动13位，因为移动
      的位数是所有26个字母的一半，所以对文本再次执行这个算啊，就恢复到了它最初的形式，如下：
echo 'shiyanlou' | tr 'a-zA-Z' 'n-za-mN-ZA-N' # 加密
echo 'fuvlnaybh' | tr 'a-zA-Z' 'n-za-mN-ZA-N' # 解密

(26)sort命令
同文本文件打交道时，总是避不开排序，那是因为对于文本处理任务而言，排序(sort)可以起到不小的作用。
sort命令能够帮助我们对文本文件和stdin进行排序操作，通常会结合其它命令来生成所需要的输出。
命令格式：
sort [选项] [文件名]
-n：基于字符串的长度来排序，使用此选项允许根据数字值排序，而不是字母值
-k：指定排序关键字
-b：默认情况下，对整行进行排序，从每行的第一个字符开始，这个选项导致sort忽略每行开头的空格，从第一个非空白字符开始排序
-m：只合并多个输入文件
-r：按相反顺序排序，结果按照降序排列，而不是升序
-t：自定义分隔符，默认为制表符
常用范例：
例一：列出/usr /share/目录下使用空间最多的前10个目录文件，如下：
du -s /usr/share/* | sort -nr | head -10
例二：ls命令能显示目录下文件的详细信息，包含空间使用大小，但与du命令不同的是，ls命令不计算目录下的子目录和文件的大小。
      现在想要对ls命令输出信息中的空间使用大小字段进行排序，如下：
ls -l /usr/bim/ | sort -nr -k 5 | head -10
例三：首先来看看下面的例子：
cat data.txt
a  5  20/10/2014
c  7  18/10/2014
b  2  01/12/2014
a  11 28/09/2014
sort data.txt
a  11 28/09/2014
a  5  20/10/2014
b  2  01/12/2014
c  7  18/10/2014
由于11由1开始，比5小，所以排在5的前面，这时排序可以通过自定义排序字段来排序，如下：
sort -k 1,1 -k 2n data.txt
第一个-k选项指明只对第一个字段排序，1,1意味着"始于并且结束于第一个字段"。第二个-k选项2n表示对第二个字段按数值排序。
还有一种格式，如-k 3.4n，表示始于第三个字段的第四个字符，按数值排序。
sort -k 3.4nb data.txt
a  11 28/09/2014
a  5  20/10/2014
c  7  18/10/2014
b  2  01/12/2014
-k选项的语法格式如下：
[ FStar [ .CStart ][ Modifier ][ , [ FEnd [ .CEnd ] ][ Modifier ] ]
这个语法格式可以被其中的逗号(',')分为两大部分，Start部分和End部分。
注：如果不设定End部分，那么就认为End被设定为行尾。
Start部分也由三部分组成，其中的Modifier部分就类似n和r的选项部分。
FStart.CStart，其中FStart就是表示使用的域，而CStart则表示在FStart域中从第几个字符开始算"排序首字符"。
CStart是可以省略的，省略的话就表示从本域的开头部分开始，例二中的-k 5就是省略了CStart的例子。
同理，在End部分中，可以设定FEnd.CEnd，如果省略.CEnd，则表示结尾到"域尾"，即本域的最后一个字符，或者将CEnd设定为0，也表示结尾到"域尾"。

(27)uniq命令
uniq命令经常和sort命令结合在一起使用，uniq从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除任何重复行。
uniq只能用于排过序的数据输入，因此uniq要么使用管道，要么将排序过的文件作为输入，并总是以这种方式与sort命令结合起来使用。
命令格式：
uniq [选项] [文件名]
常用参数：
-c：在每行前加上表示相应行目出现次数的前缀编号
-d：只输出重复的行
-u：只显示唯一的行
-D：显示所有重复的行
-f：比较时跳过前n列
-i：在比较的时候不区分大小写
-s：比较时跳过前n个字符
-w：对每行第n个字符以后的内容不作对照
常用范例：
例一：找出/bin目录和/usr/bin目录下所有相同的命令，如下：
ls /bin /usr/bin | sort | uniq -d
例二：现有文件内容如下，红色方框里的内容表示区号，现在要统计出各个区号的总人数：
cat student.txt
lisi 2000 89 1-24-56
wuli 2001 85 2-15-24
shen 2003 90 1-17-56
suya 2004 92 1-08-12
zhan 2005 86 2-06-15
实现思路：首先按区号对每行信息排序，然后使用uniq命令对区号进行重复行统计，如下：
sort -k 4.1n,4,1n student.txt | uniq -c -f 3 -w 2
3 lisi 2000 89 1-24-56
2 wuli 2001 85 2-15-24
sort -k 4.1n,4.1n 表示对第四个字段的第一个字符按数值排序。
uniq -c -f 3 -w 2 中 -f 3 表示跳过前三列的比较，那么现在只剩下最后一列，-w 2 表示第2个字符后的内容不做比较。
为什么是2呢，因为跳过前三列时并没有跳过最后一列前面的空格分隔符分隔符，区前都还有一个空格。

(28)join命令
join命令类似于paste，它会往文件中添加列，但是它使用了独特的方法来完成。
一个join操作通常与关系型数据库有关联，在关系型数据库中来自多个享有共同关键域的表格的数据结合起来，得到一个期望的结果。
这个join命令执行相同的操作，它把来自于多个基于共享关键域的文件的数据结合起来。
通俗的说就是把两个文件中指定栏位相同的行连接起来，按照两个文件中共同拥有的某一列，将对应的行拼接成一行。
命令格式：
join [选项] 文件1 文件2
常用参数：
-j FIELD：等同于 -1 FIELD -2 FIELD, -j 指定一个域作为匹配字段
-1 FIELD：以 file1 中 FIELD 字段进行匹配
-2 FIELD：以 file2 中 FIELD 字段进行匹配
-t：自定义分隔符，默认为制表符
常用范例：
例一：将两个文件中的第一个字段作为匹配字段，连接两个文件，如下：
join a.txt b.txt
例二：指定两个文件的第三个字段为匹配字段，连接两个文件，如下：
join -1 3 -2 3 c.txt d.txt
----------
join -1 3 -2 3 a.txt b.txt
join: a.txt:4: is not sorted: zhou 2600 1
join: b.txt:2: is not sorted: zhan java 2
注：因为 a.txt 和 b.txt 没有进行过排序，所以join和uniq命令一样，都需要排序之后才能使用。

(29)comm命令
通常comm命令对比较文本文件的内容很有帮助。对于系统管理员和软件开发者来说，这个命令尤为重要。
comm命令将逐行比较已经排序的两个文件，显示结果包括3列：
第1列为只在第一个文件中找到的行
第2列为只在第二个文件中找到的行
第3列为两个文件的共有行
comm命令和join，uniq命令一样，只能用于已经排序过的数据。
命令格式：
comm [选项] 文件1 文件2
常用参数：
-1：不输出文件1特有的行
-2：不输出文件2特有的行
-3：不输出了连个文件共有的行
常用案例：
例一：比较 file1.txt 和 file2.txt 两个文件的内容，如下：
comm file1.txt file2.txt
例二：比较 file1.txt 和 file2.txt 两个文件的内容，只显示两个文件共有的内容，如下：
comm -12 file1.txt file2.txt

(30)diff命令
类似comm命令，diff命令被用来监测文件之间的差异。
diff是一款更加复杂的工具，它支持许多输出格式，并且一次能处理许多文本文件。
软件开发经常使用diff程序来检查不同程序源码版本之间的更改，diff能够递归检查源码目录，通常称之为源码树。
diff程序的一个常见用例是创建diff文件或者补丁，它会被其他程序使用，例如patch程序，来把文件从一个版本转换为另一个版本。
diff在命令中打印每一行的改动，并且diff是svn，cvs，git等版本控制工具不可或缺的一部分。
命令格式：
diff [选项] 文件
-c：上下文模式，显示全部内文，并标出不同之处
-u：统一模式，以合并的方式来显示文件内容的不同
-a：只会逐行比较文本文件
-N：在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in 目录。若使用-N参数，则diff会将文件A与一个空白的文件比较。
-r：递归比较目录下的文件
常用范例：
例一：显示 file1.txt 和 file2.txt 两个文件的差异，如下：
diff file.txt file2.txt
cat file1.txt
a
b
c
12
cat file2.txt
b
c
e
10
diff file1.txt file2.txt
1d0
< 2
4c3,4
< 12
---
> e
> 10
上面结果显示中的"1d0"表示 file1.txt 文件比 file2.txt 文件多了第一行，"4c3,4"表示 file1.txt文件的第四行和 file2.txt 文件的三，四行不同。
diff的normal显示格式有三种提示：
a -add
c -change
d -delete
例二：从上面例一的显示结果可以知道，file1.txt 和 file2.txt 两个文件的差异不易直观看出，这时可以使用上下文模式显示，如下：
diff -c file1.txt file2.txt
*** file1.txt  2014-12-11 16:05:28.816493204 +0800
--- file2.txt  2014-12-11 16:05:38.892610139 +0800
***************
*** 1,4 ****
- a
  b
  c
! 12
--- 1,4 ----
  b
  c
! e
! 10
这个输出结果以两个文件名和它们的时间戳开头。
第一个文件用星号做标记，第二个文件用短横线做标记。
纵观列表的其它部分，这些标记将象征他们各自代表的文件。
*** 1,4 **** 表示第一个文件中第一行到第四行的文本行
--- 1,4 ---- 表示第二个文件中第一行到第四行的文本行
三种特殊字符：
+添加行：这一行将会出现在第二个文件内，而不是第一个文件内
-删除行：这一行将会出现在第一个文件内，而不是第二个文件内
!更改行：将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分
这些特殊字符很容易混淆，实际上记住一点：所有操作目的是将第一个文件变成第二个文件。
例三：查看 file1.txt 和 file2.txt 两个文件的差异，使用统一模式显示，如下：
diff -u file1.txt file2.txt
@@ -1,4 +1,4 @@
-a
 b
 c
-12
+e
+10
上下文模式和统一模式之间更显著的差异就是重复上下文的消除，这就使得统一模式的输出结果要比上下文模式的输出结果简短。
@@ -1,4 +1,4 @@ 表示在更改组中描述的第一个文件中的文本行和第二个文件中的文本行。
特殊字符：
+ 添加这一行到第一个文件中
- 在第一个文件中删除这一行

(31)patch命令
patch命令被用来把更改应用到文本文件中，它接受从diff程序的输出，并且通常被用来把较老的文件版本转变为较新的文件版本。
Linux内核是由一个大型的，组织松散的贡献者团队开发而成，这些贡献者会提交固定的少量更改到源码包中。
这时就可以提交一个diff文件，一个diff文件包含先前的内核版本与带有贡献者修改的新版本之间的差异。
然后一个接受者使用patch程序，把这些更改应用到他自己的源码树中。
使用diff/patch组合提供了两个重大优点：
1.与整个源码树的大小比较而言，一个diff文件非常小。
2.一个diff文件简洁地显示了所做的修改，从而允许程序补丁的审阅者能快速地评估。
当然，diff/patch能工作于任何文本文件，不仅仅是源码文件，同样适用于配置文件或任意其他文本。
准备一个diff文件供patch命令使用，GUN文档建议这样使用diff命令：
diff -Naur old_file new_file > diff_file
old file 和 new file 部分不是单个文件就是包含文件的目录，这个 r 选项支持递归目录树。
命令格式：
patch [选项] 补丁文件
常用参数：
-p num：忽略基层文件夹
-E：如果发现了空文件，那么就删除它
-R：取消打过的补丁
常用范例：
例一：生成 file1.txt 和 file2.txt 的 diff 文件，然后应用 patch 命令更新 file1.txt 文件，如下：
diff -Naur file1.txt file2.txt > patchdiff.txt
patch < patchdiff.txt
cat file1.txt
a
b
c
12
cat file2.txt
b
c
e
10
diff -Naur file1.txt file2.txt > patchdiff.txt
patch < patchdiff.txt
patching file file1.txt
cat file1.txt
b
c
e
10
例二：取消上面例一打过的补丁，如下：
patch -R < patchdiff.txt
patching file file1.txt
cat file1.txt
a
b
c
12

(32)df命令
linux中df命令的功能是用来检查linux服务器的文件系统的批判空间占用情况。
可以利用该命令来获取磁盘被占用的空间，目前还剩下多少空间等信息。
命令格式：
df [选项] 文件
常用参数：
-a：全部文件系统列表
-h：方便阅读方式显示
-i：显示inode信息
-T：文件系统类型
-t<文件系统类型>：只显示选定文件系统的磁盘信息
-x<文件系统类型>：不显示选定文件系统的磁盘信息
常用范例：
例一：显示磁盘使用情况，如下：
df
例二：以inode模式来显示磁盘使用情况，如下：
df -i
例三：列出文件系统的类型，如下：
df -T
例四：显示指定类型磁盘，如下：
df -t ext4

(33)du命令
linux中du命令也是查看使用空间的，但是与df命令不同的是du命令是对文件和目录磁盘使用的空间的查看。
命令格式：
du [选项] 文件
常用参数：
-a：显示目录中所有文件的大小
-b：显示目录或文件大小时，以byte为单位
-c：除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和
-k：以KB(1024bytes)为单位输出
-m：以MB为单位输出
-s：仅显示总计，只列出最后加总的值
-h：以K,M,G为单位，提高信息的可读性
常用范例：
例一：显示指定文件所占空间，以方便阅读的格式显示，如下：
du -h file1.txt
例二：显示指定目录所占空间，以方便阅读的格式显示，如下：
du -h Desktop
例三：显示几个文件或目录各占用磁盘空间的大小，并且统计总和，如下：
du -ch file1.txt file2.txt
例四：按照空间大小逆序排序显示，如下：
du -h | sort -nr | head -10

(34)time命令
time命令常用于测量一个命令的运行时间，包括实际使用时间(real time)，用户态使用时间(the process spent in user mode)，
内核态使用时间(the process spent in kernel mode)。
实际时间：command命令行开始执行到运行终止的时间。
用户态使用时间：命令执行完成花费的用户CPU时间，即命令在用户态中执行时间总和。
内核态使用时间：命令执行完成花费的系统CPU时间，即命令在核心态中执行时间总和。
命令格式：
time 命令
常用范例：
例一：测量date命令运行时间，如下：
time date
2014年 12月 22日 星期一 17:49:40 CST
real         0m0.005s
user         0m0.001s
sys          0m0.001s
从上面的结果可以看到：实际运行时间为0.005s，用户cpu时间为0.001s，系统cpu时间为0.001s。
其中，用户CPU时间和系统CPU时间之和为CPU时间，即命令占用cpu执行的时间总和。
实际时间要大于CPU时间，因为linux是多任务操作系统，往往在执行一条命令时，系统还要处理其他任务。
例二：将time命令的执行结果保存到文件中，如下：
{ time date; } 2>1.txt
(time date) 2>2.txt
注：{time date} 2>1.txt 大括号没有空格，且没有分号 错误
注：{time date?} 2>1.txt 大括号没有空格 错误
time 是 shell 的关键字，shell 做了特殊处理，它会把time命令后面的命令行作为一个整体来进行处理。
在重定向时，实际上是针对后面的命令来的，time命令本身的输出并不会被重定向的。
比如：执行 time date 2>3.txt，3.txt 的内容为空，另外 time 命令的输出信息是打印在标准错误输出上的。
